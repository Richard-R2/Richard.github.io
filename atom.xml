<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>灰帽子</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://richardrenn.github.io/"/>
  <updated>2019-08-11T10:11:44.683Z</updated>
  <id>https://richardrenn.github.io/</id>
  
  <author>
    <name>任令仓</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python - Celery - 调用任务</title>
    <link href="https://richardrenn.github.io/Python-Celery-Calling-Tasks.html"/>
    <id>https://richardrenn.github.io/Python-Celery-Calling-Tasks.html</id>
    <published>2019-07-28T08:35:54.000Z</published>
    <updated>2019-08-11T10:11:44.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><blockquote><p>有3个任务：add作加法运算, mul作乘法运算, xsum为求和运算</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.task(bind=True, base=BaseTask)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task(bind=True, base=BaseTask)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task(bind=True, base=BaseTask)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xsum</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(args)</span><br></pre></td></tr></table></figure><h2 id="1-立即执行任务"><a href="#1-立即执行任务" class="headerlink" title="1.立即执行任务"></a>1.立即执行任务</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add.apply_async()</span><br></pre></td></tr></table></figure><blockquote><p>或者简写为：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add.delay()</span><br></pre></td></tr></table></figure><h2 id="2-延时任务"><a href="#2-延时任务" class="headerlink" title="2.延时任务"></a>2.延时任务</h2><blockquote><p>使用<code>countdown</code>参数使任务在60秒后执行：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add.apply_async(countdown=<span class="number">60</span>)</span><br></pre></td></tr></table></figure><h2 id="3-定时任务"><a href="#3-定时任务" class="headerlink" title="3.定时任务"></a>3.定时任务</h2><blockquote><p>使用<code>eta</code>参数使任务在晚上9点整执行：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">exec_at = datetime.datetime(<span class="number">2019</span>, <span class="number">7</span>, <span class="number">28</span>, <span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">add.apply_async(eta=exec_at)</span><br></pre></td></tr></table></figure><h2 id="4-任务分组"><a href="#4-任务分组" class="headerlink" title="4.任务分组"></a>4.任务分组</h2><blockquote><p>使用<code>group</code>生成一组任务并发执行</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tasks = group(add.si(x,x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">tasks.apply_async()</span><br><span class="line"></span><br><span class="line"><span class="comment"># get方法可获取任务的返回值:</span></span><br><span class="line">res = tasks()</span><br><span class="line">res.get(timeout=<span class="number">1</span>)  <span class="comment"># [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]</span></span><br></pre></td></tr></table></figure><h2 id="5-任务分块"><a href="#5-任务分块" class="headerlink" title="5.任务分块"></a>5.任务分块</h2><blockquote><p>使用<code>chord</code>将1000个任务分成100个一块，共10组</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tasks = add.chunks(((x, x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1000</span>)), <span class="number">100</span>).group()  <span class="comment"># 转化为group</span></span><br><span class="line"><span class="comment"># 每间隔60秒执行一组</span></span><br><span class="line">tasks.skew(step=<span class="number">60</span>)</span><br><span class="line">tasks.apply_async()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意使用了skew后eta参数会失效，想要定时效果可以转化为countdown如：</span></span><br><span class="line">task.apply_async(countdown=(exec_at - now()).seconds)</span><br></pre></td></tr></table></figure><h2 id="6-链式顺序执行"><a href="#6-链式顺序执行" class="headerlink" title="6.链式顺序执行"></a>6.链式顺序执行</h2><blockquote><p>任务签名<code>signature</code>：<br>subtask=signature，可以简写为<code>s</code>，如add.s()，当需要对任务做一定处理后执行时使用。<br><code>s</code>和<code>si</code>的区别：<br><code>s</code>相当于signature()，而<code>si</code>相当于signature(immutable=True)。 <code>s</code>会把上个任务的结果传给下个任务，而<code>si</code>不传递结果。</p></blockquote><blockquote><p>使用<code>chain</code>按顺序执行一队任务：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前一个任务的结果作为后一个任务的第一个参数</span></span><br><span class="line">chain(add.s(<span class="number">1</span>,<span class="number">1</span>), add.s(<span class="number">2</span>), add.s(<span class="number">3</span>))()  </span><br><span class="line"></span><br><span class="line"> <span class="comment"># 不传递结果，仅仅按顺序执行</span></span><br><span class="line">chain(add.si(<span class="number">1</span>,<span class="number">1</span>), add.si(<span class="number">2</span>,<span class="number">2</span>), add.si(<span class="number">3</span>,<span class="number">3</span>))()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用 | 链接任务，效果是一样的，如:</span></span><br><span class="line">all_task = (add.s(<span class="number">1</span>,<span class="number">1</span>) | add.s(<span class="number">2</span>) | add.s(<span class="number">3</span>))</span><br><span class="line">all_task = (add.si(<span class="number">1</span>,<span class="number">1</span>) | add.si(<span class="number">2</span>，<span class="number">2</span>) | add.si(<span class="number">3</span>，<span class="number">2</span>))</span><br><span class="line">all_task.delay()</span><br><span class="line"></span><br><span class="line"><span class="comment"># chain还支持部分传参，如：</span></span><br><span class="line">c = (add.s(<span class="number">2</span>) | mul.s(<span class="number">8</span>))</span><br><span class="line">res = c(<span class="number">1</span>)  <span class="comment"># (1+2)*8</span></span><br><span class="line">res.get()  <span class="comment"># 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搭配列表生成式实现更灵活,如</span></span><br><span class="line">task_list = [add.si(x,x) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">chain(*task_list)()  <span class="comment"># 不要忘了加上最后的括号才可执行任务</span></span><br></pre></td></tr></table></figure><blockquote><p>另一种调用方法:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c =   (add.s(<span class="number">4</span>, <span class="number">16</span>) | mul.s(<span class="number">2</span>) | (add.s(<span class="number">4</span>) | mul.s(<span class="number">8</span>))) <span class="comment"># ((4 + 16) * 2 + 4) * 8</span></span><br><span class="line">res = c.apply_async()  <span class="comment"># 或者直接c()</span></span><br><span class="line">res.get()  <span class="comment"># .get()方法可以获取链式任务的最终返回值352</span></span><br></pre></td></tr></table></figure><h2 id="7-任务分割"><a href="#7-任务分割" class="headerlink" title="7.任务分割"></a>7.任务分割</h2><blockquote><p>使用<code>chord</code>将任务分为<code>header</code>和<code>body</code>两部分，<code>header</code>任务执行完再执行<code>body</code>,其中<code>header</code>的返回结果会作为参数传递给<code>body</code>，如：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = chord(header=[add.s(<span class="number">1</span>,<span class="number">2</span>),mul.s(<span class="number">3</span>,<span class="number">4</span>)],body=add.s())()  <span class="comment"># 任务(1+2)+(3*4)</span></span><br><span class="line">res.get()  <span class="comment">#</span></span><br></pre></td></tr></table></figure><blockquote><p>当一个<code>group</code>和另一个<code>task</code>组成<code>chain</code>时，会自动升级转化为<code>chord</code>，如：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = (group(add.s(i, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)) | xsum.s())  <span class="comment"># (0+0)+(1+1)+(2+2)+...+(9+9)</span></span><br><span class="line">res = c()</span><br><span class="line">res.get()  <span class="comment"># 90</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Celery任务可以根据不同场景很灵活的调用：延迟执行、定时执行、分组并发执行、链式顺序执行、任务分块、任务分割等等。
    
    </summary>
    
      <category term="Python" scheme="https://richardrenn.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://richardrenn.github.io/tags/Python/"/>
    
      <category term="Celery" scheme="https://richardrenn.github.io/tags/Celery/"/>
    
      <category term="调用任务" scheme="https://richardrenn.github.io/tags/%E8%B0%83%E7%94%A8%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Python - OpenCV - 截取视频某个时间点的一帧</title>
    <link href="https://richardrenn.github.io/Python-OpenCV-Snapshot.html"/>
    <id>https://richardrenn.github.io/Python-OpenCV-Snapshot.html</id>
    <published>2019-07-16T14:47:20.000Z</published>
    <updated>2019-07-22T17:14:22.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-起因"><a href="#1-起因" class="headerlink" title="1.起因"></a>1.起因</h2><p>最近在做一个短视频类的小程序，需要从用户上传的视频中截取封面图。因为有些用户喜欢用“名不副实”的封面来吸引人点进去，所以拟截取视频播放1秒时的一帧图片作为封面。</p><h2 id="2-安装OpenCV库"><a href="#2-安装OpenCV库" class="headerlink" title="2.安装OpenCV库"></a>2.安装<code>OpenCV</code>库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br></pre></td></tr></table></figure><h2 id="3-截取1秒时的一帧"><a href="#3-截取1秒时的一帧" class="headerlink" title="3.截取1秒时的一帧"></a>3.截取1秒时的一帧</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">video_path = <span class="string">"/home/richard/oss_tmp/a.mp4"</span></span><br><span class="line">cover_path = <span class="string">"/home/richard/oss_tmp/a_cover.jpg"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    vc = cv2.VideoCapture(video_path)  <span class="comment"># 读取视频</span></span><br><span class="line">    video_width = int(vc.get(cv2.CAP_PROP_FRAME_WIDTH))  <span class="comment"># 视频宽度</span></span><br><span class="line">    video_height = int(vc.get(cv2.CAP_PROP_FRAME_HEIGHT))  <span class="comment"># 视频高度</span></span><br><span class="line">    vc.set(cv2.CAP_PROP_POS_MSEC, <span class="number">1000</span>)  <span class="comment"># 设置读取位置，1000毫秒</span></span><br><span class="line">    rval, frame = vc.read()  <span class="comment"># 读取当前帧，rval用于判断读取是否成功</span></span><br><span class="line">    <span class="keyword">if</span> rval:</span><br><span class="line">        cv2.imwrite(cover_path, frame)  <span class="comment"># 将当前帧作为图片保存到 cover_path</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"读取失败"</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">f"获取视频封面图失败: <span class="subst">&#123;e&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      OpenCV 库的简单使用，截取视频1秒时的一帧图片，并保存到本地。
    
    </summary>
    
      <category term="Python" scheme="https://richardrenn.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://richardrenn.github.io/tags/Python/"/>
    
      <category term="OpenCV" scheme="https://richardrenn.github.io/tags/OpenCV/"/>
    
      <category term="视频截图" scheme="https://richardrenn.github.io/tags/%E8%A7%86%E9%A2%91%E6%88%AA%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>GitHub - 存储大文件</title>
    <link href="https://richardrenn.github.io/GitHub-Large-File-Storage.html"/>
    <id>https://richardrenn.github.io/GitHub-Large-File-Storage.html</id>
    <published>2019-05-11T15:25:37.000Z</published>
    <updated>2019-08-11T09:58:09.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题的产生"><a href="#问题的产生" class="headerlink" title="问题的产生"></a>问题的产生</h2><blockquote><p>我在GitHub上有一个仓库用来存放收集到的各种技术类书籍的电子版，但是众所周知GitHub默认情况下是不支持存储超过100M的单个文件的（其实超过50M时就会有Warning）。<br>当我push比较大的PDF版的书籍（比如<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JpY2hhcmRSZW5uL0Jvb2tzL2Jsb2IvbWFzdGVyL0phdmFTY3JpcHQvSmF2YVNjcmlwdC1ET00lRTclQkMlOTYlRTclQTglOEIlRTglODklQkElRTYlOUMlQUYtJUU0JUI4JUFEJUU2JTk2JTg3JUU3JUFDJUFDMiVFNyU4OSU4OC5wZGY=" title="https://github.com/RichardRenn/Books/blob/master/JavaScript/JavaScript-DOM%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF-%E4%B8%AD%E6%96%87%E7%AC%AC2%E7%89%88.pdf">JavaScript-DOM编程艺术-中文第2版.pdf<i class="fa fa-external-link"></i></span>）时就会抛Error：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote: error: File xxx is 109.19 MB; this exceeds GitHub&apos;s file size limit of 100.00 MB</span><br></pre></td></tr></table></figure><p><img src="/images/GitHub-Large-File-Storage/error-file-size-limit.png" alt="error-file-size-limit"></p><blockquote><p>下面是使用Git大文件存储扩展LFS来使GitHub支持大文件的版本管理的步骤：</p></blockquote><h2 id="1-安装lfs"><a href="#1-安装lfs" class="headerlink" title="1.安装lfs"></a>1.安装lfs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure><h2 id="2-添加想要被托管的大文件"><a href="#2-添加想要被托管的大文件" class="headerlink" title="2.添加想要被托管的大文件"></a>2.添加想要被托管的大文件</h2><blockquote><p>也可以直接添加一类文件，比如我的PDF文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs track <span class="string">"*.pdf"</span></span><br></pre></td></tr></table></figure><blockquote><p>同时把仓库根目录下的.gitattributes也加入到git管理下</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .gitattributes</span><br></pre></td></tr></table></figure><h2 id="3-正常提交"><a href="#3-正常提交" class="headerlink" title="3. 正常提交"></a>3. 正常提交</h2><blockquote><p>和正常的git提交命令一样</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add file.pdf</span><br><span class="line">git commit -m <span class="string">"Add new JS book"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p><img src="/images/GitHub-Large-File-Storage/git-push-successfully.png" alt="git-push-successfully"></p><blockquote><p>以上就是全部的步骤，下面是福利~</p></blockquote><hr><h2 id="福利-书架"><a href="#福利-书架" class="headerlink" title="福利 - 书架"></a>福利 - 书架</h2><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JpY2hhcmRSZW5uL0Jvb2tz" title="https://github.com/RichardRenn/Books">&gt;&gt;传送门 - 我的书架&lt;&lt;<i class="fa fa-external-link"></i></span><br>有需要的同学可以下载下来，哦，最好是挑对自己有用书籍下载单个文件，因为整个仓库可能会有几十个G。</p></blockquote>]]></content>
    
    <summary type="html">
    
      GitHub限制单个文件不能超过100M。本文将介绍如何使用Git大文件存储扩展LFS（Large File Storage）来管理超过100M大小的大文件。
    
    </summary>
    
      <category term="GitHub教程" scheme="https://richardrenn.github.io/categories/GitHub%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Git" scheme="https://richardrenn.github.io/tags/Git/"/>
    
      <category term="GitHub" scheme="https://richardrenn.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>Python - Super()继承顺序 - MRO顺序C3算法解析</title>
    <link href="https://richardrenn.github.io/Python-Super.html"/>
    <id>https://richardrenn.github.io/Python-Super.html</id>
    <published>2019-04-18T14:29:39.000Z</published>
    <updated>2019-07-23T16:36:26.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-拓扑排序算法"><a href="#1-拓扑排序算法" class="headerlink" title="1.拓扑排序算法"></a>1.拓扑排序算法</h2><p>在解析MRO之前，需要先理解<strong>拓扑排序</strong>（Topological Sorting）算法</p><blockquote><p>在图论中，当有向无环图（Directed Acyclic Graph,简称DAG）的所有顶点组成一个线性序列，且该序列满足以下条件：<br>1.每个顶点出现且只出现一次；<br>2.若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。<br>则称该序列是此DAG的一个拓扑排序。</p></blockquote><p>那么这个序列是如何得到的呢？</p><blockquote><p>1.选择一个入度为0（即只有出边没有入边）的顶点并输出；<br>2.删除此顶点及所有出边。<br>循环执行上面两步直到不存在入度为0的顶点为止，顶点输出的顺序即为拓扑排序。</p></blockquote><p>用图比较容易理解：</p><p><img src="/images/Python-Super/Topological-Sorting.png" alt="Topological-Sorting"></p><blockquote><p>拓扑排序得到的序列为：5 → 4 → 2 → 3 → 1</p></blockquote><blockquote><p><em>注意：在某些情况下拓扑排序可有多个结果</em></p></blockquote><h2 id="2-MRO-C3算法的工作原理"><a href="#2-MRO-C3算法的工作原理" class="headerlink" title="2.MRO - C3算法的工作原理"></a>2.MRO - C3算法的工作原理</h2><blockquote><p>Python的Super()函数的方法解析顺序（Method Resolution Order, 简称MRO）使用的<strong>C3算法</strong>，可以理解为在拓扑排序算法的基础上考虑了基类出现的先后顺序。</p></blockquote><blockquote><p>C3算法的本质就是Merge，<strong>Merge规则</strong>如下：<br><strong>取第一序列的第一元素，与所有后续序列除第一元素外的所有元素进行比较。</strong><br><strong>若不存在相同者，则取出这个元素并从全部序列中删除；</strong><br><strong>若存在，则跳过此序列，取下一序列的第一元素往后进行相同的比较，直到可以取出某个元素并从全部序列中删除。</strong><br><strong>然后回到最前面的序列，取第一元素进行下一轮循环比较，直到取出所有元素。取出的元素组成的列表即为<strong>mro</strong>列表。</strong></p></blockquote><blockquote><p>之所以使用这个算法，是因为基于深度优先的搜索算法（见后文）不满足本地优先级和单调性的需求。<br><strong>本地优先级</strong>：指声明时父类的顺序，比如D(B,C)，则访问D类对象属性时，应该优先查找B，然后再查找C。<br><strong>单调性</strong>：如果在D的解析顺序中，B在C的前面，那么在D的所有子类里，也必须满足这个顺序。</p></blockquote><p>试看以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span><span class="params">(D, C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>假设X.<strong>mro</strong> = L(X), +为merge，则C3算法的过程为：</p><blockquote><p>L(E) = E + L(D) + L(C) + DC<br>L(E) = E + [D+L(B)+L(C)+BC] + [C+L(A)+A] + DC<br>L(E) = E + [D + [B+L(A)+A] + [C+L(A)+A] + BC] + [C+A+A] + DC<br>L(E) = E + [D + BA + CA + BC] + CA + DC<br>L(E) = E + DBCA + CA + DC<br>L(E) = EDBCA</p></blockquote><blockquote><p>排序结果为：E → D → B → C → A → object</p></blockquote><p>到此为止，基本可以理解MRO的排序算法的运算过程了。</p><hr><h2 id="3-如何直接查看某个类的继承顺序？"><a href="#3-如何直接查看某个类的继承顺序？" class="headerlink" title="3.如何直接查看某个类的继承顺序？"></a>3.如何直接查看某个类的继承顺序？</h2><p>每个类都有对应的<strong>mro</strong>属性和mro()方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E.__mro__</span><br><span class="line">E.mro()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&lt;class &apos;__main__.E&apos;&gt;, &lt;class &apos;__main__.D&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;object&apos;&gt;)</span><br><span class="line">[&lt;class &apos;__main__.E&apos;&gt;, &lt;class &apos;__main__.D&apos;&gt;, &lt;class &apos;__main__.B&apos;&gt;, &lt;class &apos;__main__.C&apos;&gt;, &lt;class &apos;__main__.A&apos;&gt;, &lt;class &apos;object&apos;&gt;]</span><br></pre></td></tr></table></figure><h2 id="4-什么是深度优先算法？"><a href="#4-什么是深度优先算法？" class="headerlink" title="4.什么是深度优先算法？"></a>4.什么是深度优先算法？</h2><blockquote><p>这是Python2.3之前的版本所使用的搜索算法，也是所有Python2.x版本中默认的经典类的搜索算法。</p></blockquote><p>试看以下代码在2.2版本中的搜索结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"in A"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="comment"># def foo():</span></span><br><span class="line">    <span class="comment">#     print("in B")</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"in C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">D().foo()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in A</span><br></pre></td></tr></table></figure><blockquote><p>按照深度优先的原则: D → B → A → C，当B或A中有foo()方法时，根本轮不到去找C类中的foo()方法！</p></blockquote><blockquote><p>为了解决这个问题，在Python2.3版本引入了新式类（使用C3算法），但是必须显式的声明继承自object才能生效。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">···</span><br></pre></td></tr></table></figure><blockquote><p><em>Python3.x版本所有类默认为新式类，不必显式的声明。</em><br><em>另：经典类中所有的特性都是可读可写的, 新式类中的特性只读的, 只能通过添加特性达到目的。</em></p></blockquote><hr><h2 id="5-引申：介绍下广度优先算法"><a href="#5-引申：介绍下广度优先算法" class="headerlink" title="5.引申：介绍下广度优先算法"></a>5.引申：介绍下广度优先算法</h2><blockquote><p>广度优先算法是优先查找距离最近的节点，即横向查找。<br>则上面的代码排序结果为：D → B → C → A<br>而使用第二部分的代码，排序结果为：E → D → C → B → A → object</p></blockquote>]]></content>
    
    <summary type="html">
    
      解析Python多继承中Super()函数的方法解析顺序(MRO)，并举例理解它所使用的C3算法的工作原理。
    
    </summary>
    
      <category term="Python" scheme="https://richardrenn.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://richardrenn.github.io/tags/Python/"/>
    
      <category term="Super()继承顺序" scheme="https://richardrenn.github.io/tags/Super-%E7%BB%A7%E6%89%BF%E9%A1%BA%E5%BA%8F/"/>
    
      <category term="MRO" scheme="https://richardrenn.github.io/tags/MRO/"/>
    
      <category term="C3算法" scheme="https://richardrenn.github.io/tags/C3%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python - 数组切片、更新、排序</title>
    <link href="https://richardrenn.github.io/Python-List-Slice.html"/>
    <id>https://richardrenn.github.io/Python-List-Slice.html</id>
    <published>2019-04-10T12:57:45.000Z</published>
    <updated>2019-07-23T16:37:14.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数组切片"><a href="#1-数组切片" class="headerlink" title="1.数组切片"></a>1.数组切片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">l[:]  <span class="comment"># 所有元素 </span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line">l[<span class="number">0</span>]  <span class="comment"># 第一个元素</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">l[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># 第2~4个元素，不包括第4个</span></span><br><span class="line"><span class="comment"># [2, 3]</span></span><br><span class="line"></span><br><span class="line">l[<span class="number">3</span>:]  <span class="comment"># 第4~最后一个元素</span></span><br><span class="line"><span class="comment"># [4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line">l[:<span class="number">3</span>]  <span class="comment"># 第1~4个元素，不包括第4个</span></span><br><span class="line"><span class="comment"># [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">l[:<span class="number">-1</span>]  <span class="comment"># 第1~最后一个元素，不包括最后一个</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line">l[<span class="number">2</span>:<span class="number">-1</span>:<span class="number">2</span>]  <span class="comment"># 从第3~最后一个元素中每隔2个步长取一个，不包括最后一个元素</span></span><br><span class="line"><span class="comment"># [3, 5, 7]</span></span><br><span class="line"></span><br><span class="line">l[::<span class="number">3</span>]  <span class="comment"># 每隔3个步长取一个元素</span></span><br><span class="line"><span class="comment"># [1, 4, 7]</span></span><br></pre></td></tr></table></figure><h2 id="2-数组更新"><a href="#2-数组更新" class="headerlink" title="2.数组更新"></a>2.数组更新</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">l.append(<span class="number">0</span>)  <span class="comment"># 列表最后追加一个元素0</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]</span></span><br><span class="line"></span><br><span class="line">l.extend([<span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># 列表后面追加另一个列表</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0]</span></span><br><span class="line"></span><br><span class="line">l.insert(<span class="number">1</span>, <span class="string">'0'</span>)  <span class="comment"># 在第1个元素的位置插入字符串'0'</span></span><br><span class="line"><span class="comment"># [1, '0', 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line">l[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">0</span>]  <span class="comment"># 用0替换第2~4个元素，不包括第4个</span></span><br><span class="line"><span class="comment"># [1, 0, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line">l[<span class="number">-2</span>:] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]  <span class="comment"># 将最后两个元素替换为四个0</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line">l.pop()  <span class="comment"># 弹出最后一个元素,返回该元素的值</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line">l.pop(<span class="number">0</span>)  <span class="comment"># 弹出第一个元素，返回该元素的值</span></span><br><span class="line"><span class="comment"># [2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> l[<span class="number">0</span>]  <span class="comment"># 删除第一个元素</span></span><br><span class="line"><span class="comment"># [2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><h2 id="3-数组排序"><a href="#3-数组排序" class="headerlink" title="3.数组排序"></a>3.数组排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">-9</span>]</span><br><span class="line"></span><br><span class="line">l.reverse()  <span class="comment"># l反向</span></span><br><span class="line"><span class="comment"># [-9, 8, 7, 6, 5, 4, 3, 2, 1]</span></span><br><span class="line"></span><br><span class="line">list(reversed(l))  <span class="comment"># l反向,与l.reverse()的区别：后者直接作用于l，返回None，前者返回一个迭代器</span></span><br><span class="line"></span><br><span class="line">l.sort()  <span class="comment"># 对l进行排序, 默认从小到大，升序</span></span><br><span class="line"><span class="comment"># [-9, 1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line">sorted(l)  <span class="comment"># 升序排序，与l.sort()的区别：后者直接作用于l，返回None，前者返回一个新的列表</span></span><br><span class="line"><span class="comment"># [-9, 1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line">l.sort(reverse=<span class="keyword">True</span>)  <span class="comment"># 对l进行从大到小排序，降序，可与key参数搭配灵活使用</span></span><br><span class="line"><span class="comment"># [8, 7, 6, 5, 4, 3, 2, 1, -9]</span></span><br><span class="line"></span><br><span class="line">l.sort(key=<span class="keyword">lambda</span> x: abs(x))  <span class="comment"># 按指定的方法进行排序，一般与lambda临时函数配合使用，也可以使用自定义方法如：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> abs(x) <span class="comment"># 取绝对值</span></span><br><span class="line">l.sort(key=my_f) <span class="comment"># 按自定义方法进行排序</span></span><br><span class="line"></span><br><span class="line">l = [(<span class="number">1</span>,<span class="number">2</span>), (<span class="number">-4</span>,<span class="number">3</span>), (<span class="number">6</span>,<span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">l.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])  <span class="comment"># 按子元组的第二个元素大小升序排列</span></span><br><span class="line"><span class="comment"># [(6,0), (1,2), (-4,3)]</span></span><br><span class="line"></span><br><span class="line">l.sort(key=<span class="keyword">lambda</span> x: abs(x[<span class="number">0</span>]), reverse=<span class="keyword">True</span>)  <span class="comment"># 按第一个元素的绝对值大小降序排列</span></span><br><span class="line"><span class="comment"># [(6,0), (-4,3), (1,2)]</span></span><br></pre></td></tr></table></figure><h2 id="4-其他数组操作"><a href="#4-其他数组操作" class="headerlink" title="4.其他数组操作"></a>4.其他数组操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>] * <span class="number">4</span>  <span class="comment"># [1,2]重复4次</span></span><br><span class="line"><span class="comment"># [1, 2, 1, 2, 1, 2, 1, 2]</span></span><br><span class="line"></span><br><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">l.count(<span class="number">8</span>)  <span class="comment"># 统计8出现的次数</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">l.index(<span class="number">5</span>)  <span class="comment"># 找到5第一次出现的位置索引值(列表中没有5的话会报错ValueError)</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      梳理Python数组list相关的知识点，包括数组切片、数组更新、数组排序等。
    
    </summary>
    
      <category term="Python" scheme="https://richardrenn.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://richardrenn.github.io/tags/Python/"/>
    
      <category term="数组" scheme="https://richardrenn.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="数组切片" scheme="https://richardrenn.github.io/tags/%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>Python - 浅拷贝和深拷贝解析</title>
    <link href="https://richardrenn.github.io/Python-Copy-Deepcopy.html"/>
    <id>https://richardrenn.github.io/Python-Copy-Deepcopy.html</id>
    <published>2019-03-03T15:09:23.000Z</published>
    <updated>2019-07-23T16:37:43.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-浅拷贝和深拷贝的区别"><a href="#1-浅拷贝和深拷贝的区别" class="headerlink" title="1.浅拷贝和深拷贝的区别"></a>1.浅拷贝和深拷贝的区别</h2><blockquote><p>浅拷贝(copy)：仅拷贝对象，但不拷贝此对象内的子对象。<br>深拷贝(deepcopy)：完全拷贝对象，包括其内部的子对象。</p></blockquote><h2 id="2-举例理解"><a href="#2-举例理解" class="headerlink" title="2.举例理解"></a>2.举例理解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">a = &#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>:[<span class="number">1</span>,<span class="number">2</span>]&#125;</span><br><span class="line"></span><br><span class="line">a1 = copy.copy(a)  <span class="comment"># 浅拷贝</span></span><br><span class="line">a2 = copy.deepcopy(a)  <span class="comment"># 深拷贝</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>].append(<span class="number">3</span>)</span><br><span class="line">print(a, <span class="string">'%x'</span> % id(a), <span class="string">'%x'</span> % id(a[<span class="number">1</span>]))  <span class="comment"># 使用16进制格式化输出id值</span></span><br><span class="line">print(a1, <span class="string">'%x'</span> % id(a1), <span class="string">'%x'</span> % id(a1[<span class="number">1</span>]))</span><br><span class="line">print(a2, <span class="string">'%x'</span> % id(a2), <span class="string">'%x'</span> % id(a2[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">&#123;0: 1, 1: [1, 2, 3]&#125; 220a8caf2d0 220aa969e08</span><br><span class="line">&#123;0: 1, 1: [1, 2, 3]&#125; 220a8caf318 220aa969e08</span><br><span class="line">&#123;0: 1, 1: [1, 2]&#125; 220aa937c18 220aa969ec8</span><br></pre></td></tr></table></figure><blockquote><p>从输出结果进行分析：<br>1.a、a1、a2三者的id值不同。说明不论深浅拷贝都能得到新的对象。<br>2.a1[1]和a[1]的id值相同，a2[1]和a[1]的id值不同。说明浅拷贝不能拷贝子对象，执行浅拷贝得到的对象a1的子对象和原对象a的子对象使用的是相同的一块内存，但是执行深拷贝得到的对象a2却和原对象a完全独立。这也是为什么当a[1].append(3)后，a1[1]也跟着变了，而a2[1]却没变。</p></blockquote><hr><h2 id="3-a-copy-和copy-copy-a-的区别"><a href="#3-a-copy-和copy-copy-a-的区别" class="headerlink" title="3.a.copy()和copy.copy(a)的区别"></a>3.a.copy()和copy.copy(a)的区别</h2><blockquote><p>虽然两者都是浅拷贝，但是copy.copy()能够拷贝的对象更多，即某些对象本身是没有copy属性的，比如元组(tuple)。<br>如果将上例中的a值替换为a = (1, [1,2])，那么执行a1 = a.copy()时是会报错的：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">a = (<span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">a1 = a.copy()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: &apos;tuple&apos; object has no attribute &apos;copy&apos;</span><br></pre></td></tr></table></figure><h2 id="4-手写字典深拷贝"><a href="#4-手写字典深拷贝" class="headerlink" title="4.手写字典深拷贝"></a>4.手写字典深拷贝</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep_copy</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">'''仅适用于子对象是字典的情况'''</span></span><br><span class="line">    x1 = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> x.items():</span><br><span class="line">        <span class="keyword">if</span> isinstance(v, dict):  <span class="comment"># 当子对象是字典类型时递归执行</span></span><br><span class="line">            x1[k] = deep_copy(v)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x1[k] = v</span><br><span class="line">    <span class="keyword">return</span> x1</span><br></pre></td></tr></table></figure><blockquote><p>如果子对象是数组或者元组的话，只要在赋值前价格数据类型判断，然后根据不同的类型赋值给不同的变量即可兼容。</p></blockquote>]]></content>
    
    <summary type="html">
    
      举例解析Python浅拷贝和深拷贝的区别。并手动实现字典的深拷贝。
    
    </summary>
    
      <category term="Python" scheme="https://richardrenn.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://richardrenn.github.io/tags/Python/"/>
    
      <category term="浅拷贝和深拷贝" scheme="https://richardrenn.github.io/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>Python - 装饰器</title>
    <link href="https://richardrenn.github.io/Python-Decorator.html"/>
    <id>https://richardrenn.github.io/Python-Decorator.html</id>
    <published>2019-02-20T16:35:47.000Z</published>
    <updated>2019-07-23T16:38:18.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-装饰器的概念"><a href="#1-装饰器的概念" class="headerlink" title="1.装饰器的概念"></a>1.装饰器的概念</h2><blockquote><p>装饰器(decorator):<br>装饰器是一种闭包的使用，要理解装饰器的原理必须先理解python闭包的概念。</p></blockquote><blockquote><p>关于闭包的知识可以参考<a href="/Python-Closure.html">&gt;&gt;传送门 - Python闭包&lt;&lt;</a>。</p></blockquote><h2 id="2-举例理解"><a href="#2-举例理解" class="headerlink" title="2.举例理解"></a>2.举例理解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"deco"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_deco</span><span class="params">(*args)</span>:</span>  <span class="comment"># 调用的enclosing作用域中的对象，inner_deco函数就是个闭包</span></span><br><span class="line">        print(<span class="string">"inner_deco"</span>)</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> args:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isinstance(a, int): <span class="comment"># 参数检查语句</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> func(*args)  <span class="comment"># 调用了enclosing作用域的func，所以func会被加入到inner_deco的__closure__属性中</span></span><br><span class="line">    <span class="keyword">return</span> inner_deco</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco  # 语法糖，就相当于func_sum = deco(func_sum)，此时func_sum就指向了inner_deco。可以理解为func_sum被deco装饰后变成了inner_deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_sum</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(<span class="string">"func_sum"</span>)</span><br><span class="line">    <span class="keyword">return</span> sum(args)</span><br><span class="line"></span><br><span class="line"><span class="meta">@deco</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_min</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(<span class="string">"func_min"</span>)</span><br><span class="line">    <span class="keyword">return</span> min(args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># func_sum = deco(func_sum)</span></span><br><span class="line">print(func_sum(<span class="number">1</span>,<span class="number">2</span>,<span class="string">'3'</span>))</span><br><span class="line"></span><br><span class="line">print(func_min(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">deco</span><br><span class="line">deco</span><br><span class="line">inner_deco</span><br><span class="line">0</span><br><span class="line">inner_deco</span><br><span class="line">func_min</span><br><span class="line">4</span><br></pre></td></tr></table></figure><blockquote><p>@deco只是一种语法糖写法<br>之所以打印结果中没有输出：”func_sum”，是因为在执行参数检查语句时return 0了。</p></blockquote><h2 id="3-知识点"><a href="#3-知识点" class="headerlink" title="3.知识点"></a>3.知识点</h2><h3 id="3-1-装饰器在何时生效？"><a href="#3-1-装饰器在何时生效？" class="headerlink" title="3.1 装饰器在何时生效？"></a>3.1 装饰器在何时生效？</h3><blockquote><p>在main函数之前，import时就生效了。因为@deco就相当于func_sum = deco(func_sum)，是写在最外面的。<br>如果把上述例子中最后的两个print语句注释掉的话，执行结果将会是：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deco</span><br><span class="line">deco</span><br></pre></td></tr></table></figure><h3 id="3-2-装饰器能不能返回别的函数？"><a href="#3-2-装饰器能不能返回别的函数？" class="headerlink" title="3.2 装饰器能不能返回别的函数？"></a>3.2 装饰器能不能返回别的函数？</h3><blockquote><p>当然可以，这样就可以修改函数的功能了。<br>即被装饰的函数的功能取决于inner_deco返回的是哪个函数。</p></blockquote>]]></content>
    
    <summary type="html">
    
      举例理解Python装饰器的原理，以及相关的知识点。
    
    </summary>
    
      <category term="Python" scheme="https://richardrenn.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://richardrenn.github.io/tags/Python/"/>
    
      <category term="装饰器" scheme="https://richardrenn.github.io/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python - 闭包</title>
    <link href="https://richardrenn.github.io/Python-Closure.html"/>
    <id>https://richardrenn.github.io/Python-Closure.html</id>
    <published>2019-01-28T16:35:04.000Z</published>
    <updated>2019-07-23T16:38:44.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-闭包的概念"><a href="#1-闭包的概念" class="headerlink" title="1.闭包的概念"></a>1.闭包的概念</h2><blockquote><p>闭包(closure):<br>内部函数中对enclosing作用域中的变量进行引用，这个内部函数就称为闭包。</p></blockquote><blockquote><p>关于enclosing作用域相关的知识可以参考<a href="/Python-Function-Scope.html">&gt;&gt;传送门 - Python函数作用域&lt;&lt;</a>。</p></blockquote><h2 id="2-举例解释"><a href="#2-举例解释" class="headerlink" title="2.举例解释"></a>2.举例解释</h2><blockquote><p>首先要理解python中的函数也是一个对象，它是有属性和返回值的，而在函数执行完后其内部变量会被解释器回收。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># G</span></span><br><span class="line">pass_line = <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(score)</span>:</span></span><br><span class="line">    <span class="comment"># E</span></span><br><span class="line">    print(<span class="string">"%x"</span> % id(score)) <span class="comment"># 以16进制打印score的id值</span></span><br><span class="line">    pass_line = <span class="number">90</span></span><br><span class="line">    result = <span class="string">"yes"</span> <span class="keyword">if</span> score &gt;= pass_line <span class="keyword">else</span> <span class="string">"no"</span></span><br><span class="line">    print(result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_func</span><span class="params">()</span>:</span>  <span class="comment"># score在E作用域中，inner_func就是个闭包, 有__closure__属性</span></span><br><span class="line">        <span class="comment"># L</span></span><br><span class="line">        print(score)</span><br><span class="line">    print(inner_func.__closure__)</span><br><span class="line">    <span class="keyword">return</span> inner_func</span><br><span class="line"></span><br><span class="line">f = func(<span class="number">80</span>) <span class="comment"># 语句1 func()返回了一个函数对象inner_func</span></span><br><span class="line">f() <span class="comment"># 语句2 此时f即inner_func</span></span><br><span class="line">print(f.__closure__)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">6e7e6ac0</span><br><span class="line">no</span><br><span class="line">(&lt;cell at 0x000001FC0B9AB6A8: int object at 0x000000006E7E6AC0&gt;,)</span><br><span class="line">80</span><br><span class="line">(&lt;cell at 0x0000019CDFBDB6A8: int object at 0x000000006E7E6AC0&gt;,)</span><br></pre></td></tr></table></figure><blockquote><p>两个本来语句1运行完之后，func内部的变量都已经被回收了，那么这个 80为什么还可以被语句2打印出来呢？<br>注意下这个现象f.__closure__这个元组的第一个元素的id和score变量的id值相同。<br>说明如果内部函数中对enclosing作用域中的变量进行引用之后，这个变量就会被添加到inner_func的__closure__属性这个元组中，这样因为有了这个添加到元组的引用，score变量就不会被回收了，再调用f函数时，就会在它的__closure__属性中查找score变量，这样就自然而然的可以引用了。</p></blockquote><p>理解了这个例子就可以搞懂Python的闭包了。</p><hr><h2 id="3-一个简单的应用"><a href="#3-一个简单的应用" class="headerlink" title="3.一个简单的应用"></a>3.一个简单的应用</h2><blockquote><p>下面的代码就是应用闭包达到了自定pass_line的目的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(pass_line)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_func</span><span class="params">(score)</span>:</span>  <span class="comment"># score在E作用域中，inner_func就是个闭包, 有__closure__属性</span></span><br><span class="line">        result = <span class="string">"yes"</span> <span class="keyword">if</span> score &gt;= pass_line <span class="keyword">else</span> <span class="string">"no"</span>  <span class="comment"># 此时引用了enclosing作用域中的pass_line，那么pass_line变量就被添加到了__closure__属性中</span></span><br><span class="line">        print(result)</span><br><span class="line">    <span class="keyword">return</span> inner_func</span><br><span class="line"></span><br><span class="line">f = func(<span class="number">90</span>)  <span class="comment"># 语句1 func()返回了一个函数对象inner_func</span></span><br><span class="line">f(<span class="number">80</span>)  <span class="comment"># 语句2 此时f即inner_func</span></span><br><span class="line"></span><br><span class="line">f2 = func(<span class="number">60</span>)</span><br><span class="line">f2(<span class="number">80</span>)</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="literal">no</span></span><br><span class="line"><span class="literal">yes</span></span><br></pre></td></tr></table></figure><h2 id="4-经典错误代码"><a href="#4-经典错误代码" class="headerlink" title="4.经典错误代码"></a>4.经典错误代码</h2><blockquote><p>参考<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vSm9obkFCQy9wLzQwNzY4NTUuaHRtbA==" title="https://www.cnblogs.com/JohnABC/p/4076855.html">&gt;&gt;传送门 - 闭包经典错误代码&lt;&lt;<i class="fa fa-external-link"></i></span></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">        a = a + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line">c = foo()</span><br><span class="line">c()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">会报错如下：</span><br><span class="line">local variable &apos;a&apos; referenced before assignment</span><br></pre></td></tr></table></figure><blockquote><p>这是因为在执行代码 c = foo()时，python会导入全部的闭包函数体bar()来分析其的局部变量，<br>python规则指定所有在赋值语句左面的变量都是局部变量，<br>则在闭包bar()中，变量a在赋值符号”=”的左面，被python认为是bar()中的局部变量。<br>再接下来执行print c()时，程序运行至a = a + 1时，因为先前已经把a归为bar()中的局部变量，<br>所以python会在bar()中去找在赋值语句右面的a的值，结果找不到，就会报错。解决的方法很简单:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    a = [<span class="number">1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">        a[<span class="number">0</span>] = a[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> bar</span><br></pre></td></tr></table></figure><blockquote><p>只要将a设定为一个容器就可以了。这样使用起来多少有点不爽，<br>所以在python3以后，在a = a + 1 之前，使用语句nonloacal a就可以了，该语句显式的指定a不是闭包的局部变量。</p></blockquote>]]></content>
    
    <summary type="html">
    
      使用闭包可以很方便的实现代码的封装和复用。本文将举例理解Python闭包的原理，并做一个闭包的简单应用。
    
    </summary>
    
      <category term="Python" scheme="https://richardrenn.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://richardrenn.github.io/tags/Python/"/>
    
      <category term="闭包" scheme="https://richardrenn.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Python - 函数作用域</title>
    <link href="https://richardrenn.github.io/Python-Function-Scope.html"/>
    <id>https://richardrenn.github.io/Python-Function-Scope.html</id>
    <published>2019-01-10T16:34:21.000Z</published>
    <updated>2019-07-23T16:39:34.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-函数作用域"><a href="#1-函数作用域" class="headerlink" title="1.函数作用域"></a>1.函数作用域</h2><blockquote><p>L：local 函数内部作用域；</p><p>E：enclosing 函数内部与它的内嵌函数之间；</p><p>G：global 全局作用域，在同一个.py文件最外层；</p><p>B：build-in 解释器内置作用域。</p></blockquote><h2 id="2-对象查找顺序"><a href="#2-对象查找顺序" class="headerlink" title="2.对象查找顺序"></a>2.对象查找顺序</h2><blockquote><p>L &gt; E &gt; G &gt; B</p></blockquote><h2 id="3-举例解释"><a href="#3-举例解释" class="headerlink" title="3.举例解释"></a>3.举例解释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- conding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># G</span></span><br><span class="line">pass_line = <span class="number">60</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(score)</span>:</span></span><br><span class="line">    <span class="comment"># E</span></span><br><span class="line">    pass_line = <span class="number">90</span> </span><br><span class="line">    result = <span class="string">"yes"</span> <span class="keyword">if</span> score &gt;= pass_line <span class="keyword">else</span> <span class="string">"no"</span></span><br><span class="line">    print(result)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_func</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># L</span></span><br><span class="line">        <span class="comment"># score = 81</span></span><br><span class="line">        print(score)</span><br><span class="line"></span><br><span class="line">    inner_func()</span><br><span class="line"></span><br><span class="line">    print(max(<span class="number">1</span>,<span class="number">2</span>))  <span class="comment"># B</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(<span class="number">80</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      举例介绍Python的函数作用域，以及对象的查找顺序。
    
    </summary>
    
      <category term="Python" scheme="https://richardrenn.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://richardrenn.github.io/tags/Python/"/>
    
      <category term="函数作用域" scheme="https://richardrenn.github.io/tags/%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux开机启动项目录rc.d</title>
    <link href="https://richardrenn.github.io/Linux-Msconfig.html"/>
    <id>https://richardrenn.github.io/Linux-Msconfig.html</id>
    <published>2018-12-26T09:25:35.000Z</published>
    <updated>2019-05-06T16:08:26.200Z</updated>
    
    <content type="html"><![CDATA[<p>本文以/init.d/redis-server-2脚本为例，介绍如何自定义开机启动项。</p><blockquote><p>/etc/init.d目录下是所有的启动脚本，我们可以通过以下命令来运行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/脚本名 参数</span><br></pre></td></tr></table></figure><h2 id="1-先查看下自己的开机启动级别"><a href="#1-先查看下自己的开机启动级别" class="headerlink" title="1.先查看下自己的开机启动级别"></a>1.先查看下自己的开机启动级别</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runlevel</span><br></pre></td></tr></table></figure><blockquote><p>显示   N  2<br>则当前的级别是2级,那么所有开机启动项就是在/etc/rc2.d目录下。</p></blockquote><h2 id="2-查看下原来的redis启动序号"><a href="#2-查看下原来的redis启动序号" class="headerlink" title="2.查看下原来的redis启动序号"></a>2.查看下原来的redis启动序号</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l /etc/rc2.d</span><br></pre></td></tr></table></figure><blockquote><p>这个目录下都是软链接（符号链接），链接到/etc/init.d目录。<br>显示格式如下：S/K + 序号 + 脚本名</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx 1 root root  22 Dec  2 15:37 S20redis-server -&gt; ../init.d/redis-server</span><br><span class="line">lrwxrwxrwx 1 root root  18 Aug 24  2017 S99rc.local -&gt; ../init.d/rc.local</span><br></pre></td></tr></table></figure><blockquote><p>启动序号是20<br>S开头是开机时的脚本启动顺序，按序号从小到大启动。<br>K开头表示是关机时的脚本关闭顺序，按序号从大到小关闭。</p></blockquote><h2 id="3-将启动脚本软链接到开机启动目录下"><a href="#3-将启动脚本软链接到开机启动目录下" class="headerlink" title="3.将启动脚本软链接到开机启动目录下"></a>3.将启动脚本软链接到开机启动目录下</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /etc/init.d/redis-server-2 /etc/rc2.d/S20redis-server-2</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果两个redis有主从关系的话即需要有先后启动顺序，就需要适当的增大序号，如21</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /etc/init.d/redis-server-2 /etc/rc2.d/S21redis-server-2</span><br></pre></td></tr></table></figure><blockquote><p>*也可以使用update-rc.d命令，效果相同：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-rc.d -f redis-server-2 defaults 20</span><br></pre></td></tr></table></figure><h2 id="4-取消开机启动"><a href="#4-取消开机启动" class="headerlink" title="4.取消开机启动"></a>4.取消开机启动</h2><blockquote><p>方法一：使用update-rc.d命令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-rc.d -f redis-server-slark remove</span><br></pre></td></tr></table></figure><blockquote><p>方法二：直接删除软链接</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f /etc/rc2.d/S20redis-server-slark</span><br></pre></td></tr></table></figure><h2 id="5-关于rc-local"><a href="#5-关于rc-local" class="headerlink" title="5.关于rc.local"></a>5.关于rc.local</h2><blockquote><p>rc.local也是开机启动脚本，从ls -l /etc/rc2.d 命令的输出结果也可以看出，它的启动序号是99。<br>所以rc.local里的内容是在所有更高级别的初始化脚本(rc1.d rc2.d …)运行之后再执行的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      介绍Linux系统的开机启动项目录，即rc.d目录的功能，以及如何利用此目录进行自定义开机启动项。
    
    </summary>
    
      <category term="Linux" scheme="https://richardrenn.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://richardrenn.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>服务器配置 - Redis单机多实例配置</title>
    <link href="https://richardrenn.github.io/Server-Redis-Multi-Instance.html"/>
    <id>https://richardrenn.github.io/Server-Redis-Multi-Instance.html</id>
    <published>2018-12-12T08:35:50.000Z</published>
    <updated>2019-07-23T16:40:31.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-拷贝配置文件"><a href="#1-拷贝配置文件" class="headerlink" title="1.拷贝配置文件"></a>1.拷贝配置文件</h2><blockquote><p>可以参考<a href="/Server-Redis-Configuration.html">&gt;&gt;传送门 - Redis安装配置&lt;&lt;</a>。<br>Redis安装时会生成一份默认配置/etc/redis/redis.conf，几个常用配置项如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 端口</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># pid文件路径</span><br><span class="line">pidfile /var/run/redis/redis-server.pid</span><br><span class="line"></span><br><span class="line"># 绑定ip</span><br><span class="line">bind 139.xxx.xxx.xxx 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 登录需要密码</span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line"># log文件路径</span><br><span class="line">logfile /var/log/redis/redis-server.log</span><br><span class="line"></span><br><span class="line"># 持久化输出的数据库文件</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 只增文件的文件名称</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure><blockquote><p>将配置文件拷贝一份，并修改下内容：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/redis/redis.conf /etc/redis/redis-2.conf</span><br><span class="line">vim /etc/redis/redis-2.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 端口</span><br><span class="line">port 6789</span><br><span class="line"></span><br><span class="line"># pid文件路径</span><br><span class="line">pidfile /var/run/redis/redis-2.pid</span><br><span class="line"></span><br><span class="line"># 绑定ip</span><br><span class="line">bind 139.xxx.xxx.xxx 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 登录需要密码</span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line"># log文件路径</span><br><span class="line">logfile /var/log/redis/redis-2.log</span><br><span class="line"></span><br><span class="line"># 持久化输出的数据库文件</span><br><span class="line">dbfilename dump-2.rdb</span><br><span class="line"></span><br><span class="line"># 只增文件的文件名称</span><br><span class="line">appendfilename &quot;appendonly-2.aof&quot;</span><br></pre></td></tr></table></figure><h2 id="2-手动启动"><a href="#2-手动启动" class="headerlink" title="2.手动启动"></a>2.手动启动</h2><blockquote><p>从不同的配置文件启动Redis实例</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server  /etc/redis/redis.conf</span><br><span class="line">redis-server  /etc/redis/redis-2.conf</span><br></pre></td></tr></table></figure><p>到这里两个实例都可以正常工作了。</p><hr><h2 id="3-主从配置"><a href="#3-主从配置" class="headerlink" title="*3.主从配置"></a>*3.主从配置</h2><blockquote><p>一些场景下需要配置Redis主从数据库，如读写分离。<br>Redis的主从配置还是很容易的，只要修改下从库的配置文件的slaveof项即可。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/redis/redis-2.conf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 从属关系，如果是在同一台机器上可以把ip设置为127.0.0.1</span><br><span class="line">slaveof  139.xxx.xxx.xxx  6379</span><br></pre></td></tr></table></figure><h2 id="4-设置开机启动"><a href="#4-设置开机启动" class="headerlink" title="*4.设置开机启动"></a>*4.设置开机启动</h2><blockquote><p>默认情况下只有第一个实例会开机启动，其他的实例需要手动启动，下面将讲解如何让第二个实例也开机启动。</p></blockquote><h4 id="4-1-先拷贝一份原来的启动脚本"><a href="#4-1-先拷贝一份原来的启动脚本" class="headerlink" title="4.1.先拷贝一份原来的启动脚本"></a>4.1.先拷贝一份原来的启动脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/init.d/redis-server /etc/init.d/redis-server-2</span><br></pre></td></tr></table></figure><h4 id="4-2-修改新的启动脚本"><a href="#4-2-修改新的启动脚本" class="headerlink" title="4.2.修改新的启动脚本"></a>4.2.修改新的启动脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/init.d/redis-server-2</span><br></pre></td></tr></table></figure><blockquote><p>前几行需要修改的内容如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">DAEMON=/usr/bin/redis-server</span><br><span class="line">DAEMON_ARGS=/etc/redis/redis-2.conf</span><br><span class="line">NAME=redis-server-2</span><br><span class="line">DESC=redis-server-2</span><br><span class="line"></span><br><span class="line">RUNDIR=/var/run/redis</span><br><span class="line">PIDFILE=$RUNDIR/redis-server-2.pid</span><br></pre></td></tr></table></figure><blockquote><p>*以后就可以使用下面的命令来启动/停止新的实例了</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/redis-server-2 start <span class="comment"># 启动</span></span><br><span class="line">/etc/init.d/redis-server-2 stop <span class="comment"># 停止</span></span><br></pre></td></tr></table></figure><h4 id="4-3-将新脚本加入开机启动项"><a href="#4-3-将新脚本加入开机启动项" class="headerlink" title="4.3.将新脚本加入开机启动项"></a>4.3.将新脚本加入开机启动项</h4><blockquote><p>方法一：使用update-rc.d命令，20是想要指定的启动序号。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-rc.d -f redis-server-2 defaults 20</span><br></pre></td></tr></table></figure><blockquote><p>方法二：手动添加开机启动项，可以参考这篇文章<a href="/Linux-Msconfig.html">&gt;&gt;传送门 - Linux设置开机启动项&lt;&lt;</a>，两个方法的结果是相同的。</p></blockquote><blockquote><p>配置完成，此时敲reboot重启机器就可以实现开机自动启动这两个实例了。</p></blockquote><h4 id="4-4-取消开机启动"><a href="#4-4-取消开机启动" class="headerlink" title="*4.4.取消开机启动"></a>*4.4.取消开机启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-rc.d -f redis-server-2 remove</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      项目部署过程中有时候会因机器不足或为了提高资源利用率，不得不在同一台机器上启动多个Redis实例的情况。本文将介绍如何在一台机器上配置启动多个Redis实例，并将多实例均设置为开机启动。
    
    </summary>
    
      <category term="服务器搭建" scheme="https://richardrenn.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Linux" scheme="https://richardrenn.github.io/tags/Linux/"/>
    
      <category term="服务器" scheme="https://richardrenn.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Redis" scheme="https://richardrenn.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Python - Supervisor安装配置</title>
    <link href="https://richardrenn.github.io/Server-Supervisor-Configuration.html"/>
    <id>https://richardrenn.github.io/Server-Supervisor-Configuration.html</id>
    <published>2018-12-02T16:19:22.000Z</published>
    <updated>2019-07-23T16:41:51.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install supervisor</span><br></pre></td></tr></table></figure><h2 id="2-初始化启动配置文件"><a href="#2-初始化启动配置文件" class="headerlink" title="2.初始化启动配置文件"></a>2.初始化启动配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo_supervisord_conf &gt; /etc/supervisord.conf</span><br><span class="line">vim /etc/supervisord.conf</span><br></pre></td></tr></table></figure><blockquote><p>最后面加上下面这两行内容，这样就可以从/etc/supervisor目录下自动加载所有的conf文件了。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">files = /etc/supervisor/*.conf</span><br></pre></td></tr></table></figure><h2 id="3-新建项目配置文件"><a href="#3-新建项目配置文件" class="headerlink" title="3.新建项目配置文件"></a>3.新建项目配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/<span class="built_in">log</span>/supervisor</span><br><span class="line">mkdir /etc/supervisor</span><br><span class="line">vim /etc/supervisor/happydev.conf</span><br></pre></td></tr></table></figure><blockquote><p>内容如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[program:happydev]</span><br><span class="line">directory = /var/www/happydev ;</span><br><span class="line">command = /var/www/happydev/venv/bin/gunicorn -w4 -b127.0.0.1:8003 --timeout 120  happy:app ;</span><br><span class="line">autostart = true ;</span><br><span class="line">startsecs = 5 ;</span><br><span class="line">autorestart = true ;</span><br><span class="line">startretries = 3 ;</span><br><span class="line">user = root ;</span><br><span class="line">redirect_stderr = true ;</span><br><span class="line">stdout_logfile_maxbytes = 100MB ;</span><br><span class="line">stdout_logfile_backups = 10 ;</span><br><span class="line">stdout_logfile = /var/log/supervisor/happydev.log ;</span><br><span class="line">environment = HAPPY_CONFIG_FILE=&quot;/var/www/happydev/happy/config/staging.py&quot;,HAPPY_PATH=&quot;/var/www/happydev&quot; ;</span><br></pre></td></tr></table></figure><blockquote><p>这里管理的进程是使用gunicorn启动的Flask项目，关于gunicorn的使用可以参考<a href="/Server-Gunicorn-Configuration.html">&gt;&gt;传送门 - Gunicorn安装配置&lt;&lt;</a>。</p></blockquote><h2 id="4-启动suprervisord"><a href="#4-启动suprervisord" class="headerlink" title="4.启动suprervisord"></a>4.启动suprervisord</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c /etc/supervisord.conf</span><br></pre></td></tr></table></figure><blockquote><p>到这一步supervisor已经正常工作了。</p></blockquote><hr><h2 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5.常用命令"></a>5.常用命令</h2><h4 id="5-1-停止supervisor主进程"><a href="#5-1-停止supervisor主进程" class="headerlink" title="5.1.停止supervisor主进程"></a>5.1.停止supervisor主进程</h4><blockquote><p>查看supervisord进程号(pid)：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep supervisord</span><br></pre></td></tr></table></figure><blockquote><p>关闭进程：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [pid]</span><br></pre></td></tr></table></figure><h4 id="5-2-启动单个项目进程"><a href="#5-2-启动单个项目进程" class="headerlink" title="5.2.启动单个项目进程"></a>5.2.启动单个项目进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl start happydev</span><br></pre></td></tr></table></figure><h4 id="5-3-停止单个项目进程"><a href="#5-3-停止单个项目进程" class="headerlink" title="5.3.停止单个项目进程"></a>5.3.停止单个项目进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl stop happydev</span><br></pre></td></tr></table></figure><blockquote><p>注意：使用此命令停止的进程不会被自动重启机制重新启动</p></blockquote><h4 id="5-4-重启单个项目进程"><a href="#5-4-重启单个项目进程" class="headerlink" title="5.4.重启单个项目进程"></a>5.4.重启单个项目进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl restart happydev</span><br></pre></td></tr></table></figure><h4 id="5-5-重新加载单个项目"><a href="#5-5-重新加载单个项目" class="headerlink" title="5.5.重新加载单个项目"></a>5.5.重新加载单个项目</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl remove happydev <span class="comment"># 移除happydev项目</span></span><br><span class="line">supervisorctl reread <span class="comment"># 重新读取所有配置文件</span></span><br><span class="line">supervisorctl add happydev <span class="comment"># 添加happydev项目</span></span><br></pre></td></tr></table></figure><h4 id="5-6-查看所有项目进程的运行状态"><a href="#5-6-查看所有项目进程的运行状态" class="headerlink" title="5.6.查看所有项目进程的运行状态"></a>5.6.查看所有项目进程的运行状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl status</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Supervisor是用Python开发的进程管理工具，工作于Linux/Unix系统。可以很方便的监听、启动、停止、重启一个或多个进程。并支持自动重启被意外杀死的进程。本文将介绍Supervisor的安装、配置及使用。
    
    </summary>
    
      <category term="Python" scheme="https://richardrenn.github.io/categories/Python/"/>
    
    
      <category term="Linux" scheme="https://richardrenn.github.io/tags/Linux/"/>
    
      <category term="Python" scheme="https://richardrenn.github.io/tags/Python/"/>
    
      <category term="服务器" scheme="https://richardrenn.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Supervisor" scheme="https://richardrenn.github.io/tags/Supervisor/"/>
    
  </entry>
  
  <entry>
    <title>Python - Gunicorn安装配置</title>
    <link href="https://richardrenn.github.io/Server-Gunicorn-Configuration.html"/>
    <id>https://richardrenn.github.io/Server-Gunicorn-Configuration.html</id>
    <published>2018-12-01T15:52:38.000Z</published>
    <updated>2019-07-23T16:42:13.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www/happy <span class="comment"># 进入项目代码目录</span></span><br><span class="line"><span class="built_in">source</span> venv/bin/activate <span class="comment"># 激活并进入虚拟环境</span></span><br><span class="line">pip install gunicorn <span class="comment"># 在虚拟环境中安装gunicorn</span></span><br></pre></td></tr></table></figure><h2 id="2-使用gunicorn启动Flask项目"><a href="#2-使用gunicorn启动Flask项目" class="headerlink" title="2.使用gunicorn启动Flask项目"></a>2.使用gunicorn启动Flask项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn -w4 -b127.0.0.1:8003 happy:app</span><br></pre></td></tr></table></figure><blockquote><p>这里的happy是Flask项目的app名<br>-w4 等同于 –workers=4，意为同时启动四个worker<br>-b127.0.0.1:8003 等同于 –bind=127.0.0.1:8003，用于指定绑定的服务器ip和端口</p></blockquote><h2 id="3-关闭进程"><a href="#3-关闭进程" class="headerlink" title="3.关闭进程"></a>3.关闭进程</h2><blockquote><p>Ctrl+C即可。</p></blockquote><blockquote><p>后台进程可以使用以下命令查看进程号(pid):</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep gunicorn</span><br></pre></td></tr></table></figure><blockquote><p>关闭进程命令：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> [pid]</span><br></pre></td></tr></table></figure><hr><ul><li>推荐使用supervisor来管理gunicorn进程，优点是启动、停止、重启都很方便，并且支持自动重启被意外停止的进程，可以参考<a href="/Server-Supervisor-Configuration.html">&gt;&gt;传送门 - Supervisor安装配置&lt;&lt;</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      Gunicorn是一个高性能的Python WSGI UNIX HTTP服务器，使用简单，资源消耗低，兼容flask、django等Web框架。本文将介绍Gunicorn的安装、配置及使用。
    
    </summary>
    
      <category term="Python" scheme="https://richardrenn.github.io/categories/Python/"/>
    
    
      <category term="Linux" scheme="https://richardrenn.github.io/tags/Linux/"/>
    
      <category term="Python" scheme="https://richardrenn.github.io/tags/Python/"/>
    
      <category term="服务器" scheme="https://richardrenn.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Gunicorn" scheme="https://richardrenn.github.io/tags/Gunicorn/"/>
    
  </entry>
  
  <entry>
    <title>Python - virtualenv虚拟环境配置</title>
    <link href="https://richardrenn.github.io/Python-Virtualenv.html"/>
    <id>https://richardrenn.github.io/Python-Virtualenv.html</id>
    <published>2018-11-25T15:00:54.000Z</published>
    <updated>2019-07-23T16:42:44.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure><h2 id="2-创建虚拟环境"><a href="#2-创建虚拟环境" class="headerlink" title="2.创建虚拟环境"></a>2.创建虚拟环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:RichardRenn/happy.git /var/www/happy <span class="comment"># 克隆项目代码</span></span><br><span class="line"><span class="built_in">cd</span> /var/www/happy <span class="comment"># 进入项目目录</span></span><br><span class="line">virtualenv venv <span class="comment"># 创建虚拟环境目录./venv</span></span><br></pre></td></tr></table></figure><h2 id="3-激活并进入虚拟环境"><a href="#3-激活并进入虚拟环境" class="headerlink" title="3.激活并进入虚拟环境"></a>3.激活并进入虚拟环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ./venv/bin/activate</span><br></pre></td></tr></table></figure><blockquote><p>当看到命令行前面显示(venv)标志时即表示已进入虚拟环境</p></blockquote><h2 id="4-安装需求库"><a href="#4-安装需求库" class="headerlink" title="4.安装需求库"></a>4.安装需求库</h2><blockquote><p>同在普通环境下的安装命令是相同的，只不过所有的库都会被安装到虚拟环境目录下</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install [module-name]</span><br></pre></td></tr></table></figure><blockquote><p>*也可以从需求库依赖文件安装所需库</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><blockquote><p>需求库依赖文件可以从任何一个虚拟环境中导出，导出命令如下：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><blockquote><p><em>推荐保持依赖文件为最新状态，并存放在项目代码目录下，可以很方便地在新机器上安装部署项目虚拟环境。</em></p></blockquote><h2 id="5-退出虚拟环境"><a href="#5-退出虚拟环境" class="headerlink" title="5.退出虚拟环境"></a>5.退出虚拟环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      当在同一台机器上开发多个Python项目，而不同项目要求的Python库版本又不同时，就没办法公用一个Python环境了。Python的virtualenv可以很好地解决这种情况下的矛盾，可以保证每个应用都有自己独立的一套“隔离的”虚拟环境。本文将介绍如何配置Python虚拟环境。
    
    </summary>
    
      <category term="Python" scheme="https://richardrenn.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://richardrenn.github.io/tags/Python/"/>
    
      <category term="virtualenv" scheme="https://richardrenn.github.io/tags/virtualenv/"/>
    
  </entry>
  
  <entry>
    <title>服务器配置 - Nginx安装配置</title>
    <link href="https://richardrenn.github.io/Server-Nginx-Configuration.html"/>
    <id>https://richardrenn.github.io/Server-Nginx-Configuration.html</id>
    <published>2018-11-17T11:58:56.000Z</published>
    <updated>2019-07-23T16:43:20.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install nginx</span><br></pre></td></tr></table></figure><h2 id="2-增加代理配置"><a href="#2-增加代理配置" class="headerlink" title="2.增加代理配置"></a>2.增加代理配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx/sites-available</span><br><span class="line">vim your_site_name</span><br></pre></td></tr></table></figure><blockquote><p>普通http配置参考：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># http server</span><br><span class="line">server &#123;</span><br><span class="line">       listen 80;</span><br><span class="line">       server_name your.site.name.cn;</span><br><span class="line">       # ssl on;</span><br><span class="line">       access_log /var/log/nginx/syour_site_name.access.log;</span><br><span class="line">       error_log /var/log/nginx/your_site_name.error.log;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_pass http://127.0.0.1:8011;</span><br><span class="line">proxy_set_header Host $host;</span><br><span class="line">                proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">proxy_set_header X-Forward_For $proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>安全https配置参考：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># HTTPS server</span><br><span class="line">server &#123;</span><br><span class="line">        listen 443;</span><br><span class="line">        listen [::]:443 ipv6only=on;</span><br><span class="line">        server_name your.site.name.cn;</span><br><span class="line">        ssl on;</span><br><span class="line">        access_log /var/log/nginx/your_site_name.access.log;</span><br><span class="line">        error_log /var/log/nginx/your_site_name.error.log;</span><br><span class="line">        ssl_certificate /path/to/your/https/cert/your_site_name.pem;</span><br><span class="line">        ssl_certificate_key /path/to/your/https/cert/your_site_name.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://127.0.0.1:8012;</span><br><span class="line">                proxy_set_header Host $host;</span><br><span class="line">                proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">                proxy_set_header X-Forward_For $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将文件链接至sites-enabled目录下。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /etc/nginx/sites-available/your_site_name /etc/nginx/sites-enabled/your_site_name</span><br></pre></td></tr></table></figure><blockquote><p>*这是因为sites-available目录下存放的只是备选配置，sites-enabled目录下才是真正有效的代理设置。</p></blockquote><h2 id="3-Nginx配置"><a href="#3-Nginx配置" class="headerlink" title="3.Nginx配置"></a>3.Nginx配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><blockquote><p>修改下前几行内容:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">user www-data;</span><br><span class="line">worker_processes 4; # worker数</span><br><span class="line">worker_rlimit_nofile 60000; </span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">        worker_connections 65535; # 最大同时连接数</span><br><span class="line">        multi_accept on; # 开启接受同时连接选项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-重载配置"><a href="#4-重载配置" class="headerlink" title="4.重载配置"></a>4.重载配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p>这一步做完Nginx已经可以正常工作了。</p><hr><h2 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5.常用命令"></a>5.常用命令</h2><h4 id="5-1-启动"><a href="#5-1-启动" class="headerlink" title="5.1.启动"></a>5.1.启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/nginx</span><br></pre></td></tr></table></figure><h4 id="5-2-停止"><a href="#5-2-停止" class="headerlink" title="5.2.停止"></a>5.2.停止</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/nginx -s stop</span><br></pre></td></tr></table></figure><h4 id="5-3-验证配置文件是否正确"><a href="#5-3-验证配置文件是否正确" class="headerlink" title="5.3.验证配置文件是否正确"></a>5.3.验证配置文件是否正确</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/nginx -t</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Nginx是一款高性能的Web和反向代理服务器，也可作为IMAP/POP3/SMTP代理服务器，尤其擅长处理多连接高并发的业务。本文将介绍Nginx服务器的安装配置和常用命令。
    
    </summary>
    
      <category term="服务器搭建" scheme="https://richardrenn.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Linux" scheme="https://richardrenn.github.io/tags/Linux/"/>
    
      <category term="服务器" scheme="https://richardrenn.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Nginx" scheme="https://richardrenn.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>服务器配置 - Redis安装配置</title>
    <link href="https://richardrenn.github.io/Server-Redis-Configuration.html"/>
    <id>https://richardrenn.github.io/Server-Redis-Configuration.html</id>
    <published>2018-11-11T11:39:11.000Z</published>
    <updated>2019-07-23T16:43:48.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install redis-server</span><br></pre></td></tr></table></figure><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><blockquote><p>这里仅介绍几个基本配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 端口</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># pid文件路径</span><br><span class="line">pidfile /var/run/redis/redis-server.pid</span><br><span class="line"></span><br><span class="line"># 绑定ip</span><br><span class="line">bind 139.xxx.xxx.xxx 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 登录需要密码</span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line"># log文件路径</span><br><span class="line">logfile /var/log/redis/redis-server.log</span><br><span class="line"></span><br><span class="line"># 持久化输出的数据库文件</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 只增文件的文件名称</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure><h2 id="3-重启"><a href="#3-重启" class="headerlink" title="3.重启"></a>3.重启</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/redis-server restart</span><br></pre></td></tr></table></figure><p>这一步做完redis-server已经可以正常工作了。</p><hr><h2 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4.常用命令"></a>4.常用命令</h2><h4 id="4-1-连接"><a href="#4-1-连接" class="headerlink" title="4.1.连接"></a>4.1.连接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 139.xxx.xxx.xxx -p 6379 -a 123456</span><br></pre></td></tr></table></figure><blockquote><p>如果是本地连接的话-h参数可以省略<br>使用默认端口6379的话-p参数可以省略<br>没有设置密码的话-a参数可以省略</p></blockquote><h4 id="4-2-关闭"><a href="#4-2-关闭" class="headerlink" title="4.2.关闭"></a>4.2.关闭</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure><h4 id="4-2-启动服务器"><a href="#4-2-启动服务器" class="headerlink" title="4.2.启动服务器"></a>4.2.启动服务器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><hr><ul><li>在一台机器上配置多个Redis服务器可以参考<a href="/Server-Redis-Multi-Instance.html">&gt;&gt;传送门 - Redis单机多实例配置&lt;&lt;</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      Redis(REmote DIctionary Server)是一个开源的可基于内存亦可持久化的Key-Value数据库。本文将介绍Redis服务器的安装配置和常用命令。
    
    </summary>
    
      <category term="服务器搭建" scheme="https://richardrenn.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Linux" scheme="https://richardrenn.github.io/tags/Linux/"/>
    
      <category term="服务器" scheme="https://richardrenn.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="Redis" scheme="https://richardrenn.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>服务器配置 - Nginx+Gunicorn+Supervisor+Flask</title>
    <link href="https://richardrenn.github.io/Server-Configuration.html"/>
    <id>https://richardrenn.github.io/Server-Configuration.html</id>
    <published>2018-11-10T08:47:24.000Z</published>
    <updated>2019-07-23T16:45:19.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为服务器添加ssh公钥验证"><a href="#1-为服务器添加ssh公钥验证" class="headerlink" title="1.为服务器添加ssh公钥验证"></a>1.<a href="/Server-SSH-Key.html">为服务器添加ssh公钥验证</a></h2><h2 id="2-Git安装配置"><a href="#2-Git安装配置" class="headerlink" title="2.Git安装配置"></a>2.<a href="/Git-Configuration.html">Git安装配置</a></h2><h2 id="3-Redis安装配置"><a href="#3-Redis安装配置" class="headerlink" title="3.Redis安装配置"></a>3.<a href="/Server-Redis-Configuration.html">Redis安装配置</a></h2><h2 id="4-Nginx安装配置"><a href="#4-Nginx安装配置" class="headerlink" title="4.Nginx安装配置"></a>4.<a href="/Server-Nginx-Configuration.html">Nginx安装配置</a></h2><h2 id="5-配置Python虚拟环境"><a href="#5-配置Python虚拟环境" class="headerlink" title="5.配置Python虚拟环境"></a>5.<a href="/Python-Virtualenv.html">配置Python虚拟环境</a></h2><h2 id="6-Gunicorn安装配置"><a href="#6-Gunicorn安装配置" class="headerlink" title="6.Gunicorn安装配置"></a>6.<a href="/Server-Gunicorn-Configuration.html">Gunicorn安装配置</a></h2><h2 id="7-Supervisor安装配置"><a href="#7-Supervisor安装配置" class="headerlink" title="7.Supervisor安装配置"></a>7.<a href="/Server-Supervisor-Configuration.html">Supervisor安装配置</a></h2>]]></content>
    
    <summary type="html">
    
      介绍如何使用Nginx+Gunicorn+Supervisor+Flask来搭建RESTFul-API服务器。
    
    </summary>
    
      <category term="服务器搭建" scheme="https://richardrenn.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Linux" scheme="https://richardrenn.github.io/tags/Linux/"/>
    
      <category term="服务器" scheme="https://richardrenn.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>服务器搭建 - 为服务器添加ssh公钥验证</title>
    <link href="https://richardrenn.github.io/Server-SSH-Key.html"/>
    <id>https://richardrenn.github.io/Server-SSH-Key.html</id>
    <published>2018-11-04T09:51:00.000Z</published>
    <updated>2019-07-23T16:44:34.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-生成密钥对"><a href="#1-生成密钥对" class="headerlink" title="1.生成密钥对"></a>1.生成密钥对</h2><blockquote><p>在本地运行如下命令：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">"your_email@example.com"</span></span><br></pre></td></tr></table></figure><p>如果不想设置密码的话直接三次回车即可，和git生成密钥的命令相同。</p><blockquote><p>生成的密钥对位置在 ~/.ssh，查看下公钥，下一步要用到。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><blockquote><p>内容类似下面这样</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQC+am2s/r1n+xsipi/4H2ll8p3McdhQCLBwJGNbkaxpeWKtdbiUbqAWeNt/OF13VsyWLs5lb6J2I3J6GlCcEGMGOFc4gzLTP9e/TmXeyFlBMZkuSJTbsXvL9Q/tff/8Tgt4aVAeOAgSd2jdDEvALegap4nrMHVLP8sOQlNFBMPjy1r0cW/Afp32gCtPOpQRuIkQdOnWUkzjObGanhYnX470UNsvgQ+IyikhS5tiKPqkT317v6yFV4doeZgfNYtcgpLVZcVxkItTLS1h75d4h4MD2JVRk2nBGSLp5j2WIji4Tiy++LblV1Y5Y2wRcfefdXCIMT3jMNAcyhuCaNfaD/Q== your_email@example.com</span><br></pre></td></tr></table></figure><h2 id="2-添加到服务器"><a href="#2-添加到服务器" class="headerlink" title="2.添加到服务器"></a>2.添加到服务器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh root@server_ip <span class="comment"># 登陆服务器</span></span><br><span class="line">mkdir .ssh <span class="comment"># 创建.ssh目录</span></span><br><span class="line">vim .ssh/authorized_keys <span class="comment"># 创建已验证的密钥记录文件</span></span><br></pre></td></tr></table></figure><blockquote><p>在vim编辑器中按i键，把上一步的公钥拷贝进来，多个公钥的话换行隔开即可。<br>然后按ESC键退出编辑模式，输入:wq回车即可保存文件。<br>这样以后输入ssh root@ip命令就可以不用输入密码直接进去了。</p></blockquote><a id="more"></a><h2 id="3-更快捷地登陆"><a href="#3-更快捷地登陆" class="headerlink" title="3.更快捷地登陆"></a>3.更快捷地登陆</h2><p>完成上面的配置后，还可以通过对本地ssh进行配置以进一步简化登陆操作。</p><blockquote><p>在本地打开~/.ssh/config 文件</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.ssh/config</span><br></pre></td></tr></table></figure><blockquote><p>添加如下配置内容:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host happy</span><br><span class="line">Hostname 139.xxx.xxx.xxx</span><br><span class="line">User root</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><blockquote><p>以后在本地直接输入以下命令就可登陆远程服务器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh happy</span><br></pre></td></tr></table></figure><blockquote><p>多个服务器配置只需换行隔开即可。</p></blockquote>]]></content>
    
    <summary type="html">
    
      使用ssh密钥对登陆，可以避免每次登陆都要输入密码，便捷的同时也提高了安全性。本文将介绍如何为服务器添加ssh公钥验证。
    
    </summary>
    
      <category term="服务器搭建" scheme="https://richardrenn.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Linux" scheme="https://richardrenn.github.io/tags/Linux/"/>
    
      <category term="ssh" scheme="https://richardrenn.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>GitHub教程 - 分支工作流程</title>
    <link href="https://richardrenn.github.io/GitHub-Branch-Workflow.html"/>
    <id>https://richardrenn.github.io/GitHub-Branch-Workflow.html</id>
    <published>2018-10-17T15:28:03.000Z</published>
    <updated>2019-07-23T16:50:41.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-更新代码"><a href="#1-更新代码" class="headerlink" title="1.更新代码"></a>1.更新代码</h2><blockquote><p>进入代码目录，更新代码</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/workspace/sourcecode/richardrenn/slark</span><br><span class="line">git pull origin master</span><br><span class="line">*git pull upstream master</span><br></pre></td></tr></table></figure><blockquote><p>*查看所有远端库情况</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">origin        git@github.com:RichardRenn/slark.git (fetch)</span><br><span class="line">origin        git@github.com:RichardRenn/slark.git (push)</span><br><span class="line">upstream        git@github.com:southflower/slark.git (fetch)</span><br><span class="line">upstream        git@github.com:southflower/slark.git (push)</span><br></pre></td></tr></table></figure><blockquote><p>*查看所有分支情况，可看到当前的分支是origin/master</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/master</span><br><span class="line">  remotes/origin/release</span><br><span class="line">  remotes/upstream/master</span><br><span class="line">  remotes/upstream/release</span><br></pre></td></tr></table></figure><h2 id="2-新建分支"><a href="#2-新建分支" class="headerlink" title="2.新建分支"></a>2.新建分支</h2><blockquote><p>本地新建分支，并切换到新建的分支</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure><h2 id="3-推送分支"><a href="#3-推送分支" class="headerlink" title="3.推送分支"></a>3.推送分支</h2><blockquote><p>推送新分支到远端库和上游库，冒号前的是本地分支名，冒号后的是远程分支名</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev:dev</span><br><span class="line">git push upstream dev:dev</span><br></pre></td></tr></table></figure><blockquote><p>此时再敲git branch -a 就可以看到已经在远端库和上游库都建好了分支</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br><span class="line">  remotes/origin/release</span><br><span class="line">  remotes/upstream/dev</span><br><span class="line">  remotes/upstream/master</span><br><span class="line">  remotes/upstream/release</span><br></pre></td></tr></table></figure><h2 id="4-提交修改"><a href="#4-提交修改" class="headerlink" title="4.提交修改"></a>4.提交修改</h2><blockquote><p>在本地的dev分支修改文件并提交推送到远端库</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add [file]</span><br><span class="line">git commit -m <span class="string">"something"</span></span><br><span class="line">git push origin dev</span><br><span class="line">*git push upstream dev   <span class="comment"># 这一步直接推送到上游库的dev分支，可以省一次PR</span></span><br></pre></td></tr></table></figure><h2 id="5-提交PR"><a href="#5-提交PR" class="headerlink" title="5.提交PR"></a>5.提交PR</h2><blockquote><p>在网页通过PR的方式将dev代码推送到上游库的dev分支</p></blockquote><h2 id="6-分支合入"><a href="#6-分支合入" class="headerlink" title="6.分支合入"></a>6.分支合入</h2><blockquote><p>等dev调试稳定后再通过PR的方式将上游库的dev分支merge到其master分支，即可上线</p></blockquote><hr><ul><li>PR操作可以参考<a href="/GitHub-Pull-Request-Workflow.html">&gt;&gt;传送门 - Pull Request 工作流程&lt;&lt;</a></li></ul>]]></content>
    
    <summary type="html">
    
      善用Git的分支特性可以使开发工作更清晰高效。本文将介绍分支机制的工作流程。
    
    </summary>
    
      <category term="GitHub教程" scheme="https://richardrenn.github.io/categories/GitHub%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Git" scheme="https://richardrenn.github.io/tags/Git/"/>
    
      <category term="GitHub" scheme="https://richardrenn.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>GitHub教程 - Pull Request 工作流程</title>
    <link href="https://richardrenn.github.io/GitHub-Pull-Request-Workflow.html"/>
    <id>https://richardrenn.github.io/GitHub-Pull-Request-Workflow.html</id>
    <published>2018-10-16T12:27:28.000Z</published>
    <updated>2019-07-23T16:50:22.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Fork仓库"><a href="#1-Fork仓库" class="headerlink" title="1.Fork仓库"></a>1.Fork仓库</h2><blockquote><p>先在github上将源仓库fork到自己的仓库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">源仓库：git@github.com:southflower/slark.git</span><br><span class="line">fork后：git@github.com:RichardRenn/slark.git</span><br></pre></td></tr></table></figure><h2 id="2-检出代码"><a href="#2-检出代码" class="headerlink" title="2.检出代码"></a>2.检出代码</h2><blockquote><p>在本地检出fork后的仓库代码</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/workspace/sourcecode/richardrenn</span><br><span class="line">git <span class="built_in">clone</span> git@github.com:RichardRenn/slark.git ./slark</span><br></pre></td></tr></table></figure><h2 id="3-关联上游源仓库"><a href="#3-关联上游源仓库" class="headerlink" title="3.关联上游源仓库"></a>3.关联上游源仓库</h2><blockquote><p>进入代码目录，加入上游源仓库关联</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./slark</span><br><span class="line">git remote add upstream git@github.com:southflower/slark.git</span><br></pre></td></tr></table></figure><h2 id="4-更新代码"><a href="#4-更新代码" class="headerlink" title="4.更新代码"></a>4.更新代码</h2><blockquote><p>更新源仓库代码到本地仓库</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch upstream</span><br><span class="line">git merge upstream/master</span><br></pre></td></tr></table></figure><h2 id="5-提交代码"><a href="#5-提交代码" class="headerlink" title="5.提交代码"></a>5.提交代码</h2><blockquote><p>在本地仓库中，修改代码后提交到自己的远端仓库</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"anything"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h2 id="6-提交PR"><a href="#6-提交PR" class="headerlink" title="6.提交PR"></a>6.提交PR</h2><blockquote><p>在github网页上提交PR<br>在自己的仓库界面点击”New Pull Request”</p></blockquote><p><img src="/images/GitHub-Pull-Request-Workflow/pull-request.png" alt="pull-request"></p><h2 id="7-PR合入"><a href="#7-PR合入" class="headerlink" title="7.PR合入"></a>7.PR合入</h2><blockquote><p>然后待源仓库的作者将你的PR合入即可</p></blockquote><hr><ul><li>带分支的工作方式可以参考<a href="/GitHub-Branch-Workflow.html">&gt;&gt;传送门 - 分支工作流程&lt;&lt;</a></li></ul>]]></content>
    
    <summary type="html">
    
      GitHub的PR机制一般用于多人协同完成项目开发的工作，可以使开发更便捷。本文将介绍Pull-Request工作流程。
    
    </summary>
    
      <category term="GitHub教程" scheme="https://richardrenn.github.io/categories/GitHub%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Git" scheme="https://richardrenn.github.io/tags/Git/"/>
    
      <category term="GitHub" scheme="https://richardrenn.github.io/tags/GitHub/"/>
    
  </entry>
  
</feed>
